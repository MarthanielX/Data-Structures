import java.util.*;
import java.io.*;

// Deck class 
// Author: Nathaniel Sauerberg, public method headers by Dave Musicant
// reads in, stores, and manipulates a virtual deck of cards

public class Deck {

   private Node head;

   //represents one node of a doubly linked list
   public class Node{
   
      private Integer data;
      private Node prev; 
      private Node next;
       
      public Node (Integer data, Node prev, Node next){
         this.data = data;
         this.prev = prev;
         this.next = next;
      }
   }
   
   // scans file of ints separated by spaces into a double linked list
   public Deck(String filename) throws FileNotFoundException{
      File file = new File(filename);
      Scanner input = new Scanner(file);
      if (input.hasNext()){
         head = new Node(input.nextInt(), null, null);
      }
      Node current = head;
      while (input.hasNext()){
         Node newNode = new Node (input.nextInt(), current, null);
         current.next = newNode;
         current = newNode;
      }
      current.next = head; //wraps around to top of deck
      head.prev = current; //sets last value to head.prev
   }
   
   // prints first n cards in deck starting with the first,
   // wrapping around to the front if n > number of cards
   public void print(int n){
      Node current = head;
      for (int i = 0; i < n; i++){
         System.out.print(current.data + " ");
         current = current.next;
      }
      System.out.println();
   }
   
   // prints last n cards in deck starting from the last,
   // wrapping around to the back if n > number of cards
   public void printBackwards(int n){
      Node current = head.prev;
      for (int i = 0; i < n; i++){
         System.out.print(current.data + " ");
         current = current.prev;
      }
      System.out.println();
   }
   
   // goes through 5 steps of deck manipulation and 
   // returns the value generated by the steps
   public int nextKeyValue(){
      
      int keyValue = 27; 
      // repeat until key value is not a joker
      while ( keyValue == 27 || keyValue == 28) {
      
      // find joker A, swap with card after
         Node current = findCard(27);
         swapValue(current, current.next);
      
      // find joker B, move it 2 cards down
         current = findCard(28);
         swapValue(current, current.next);
         current = current.next;
         swapValue(current, current.next);

      // triple cut: switch cards above 1st joker with cards below 2nd
         Node firstJoker = head; 
         while (firstJoker.data != 27 && firstJoker.data != 28){
            firstJoker = firstJoker.next;
         }
         Node secondJoker = firstJoker.next;
         while (secondJoker.data != 27 && secondJoker.data != 28){
            secondJoker = secondJoker.next;
         }
         Node toBeHead = secondJoker.next;
         moveChain(secondJoker.next, head.prev, firstJoker.prev);    
         head = toBeHead;
      
      // look at bottom card, data = n
      // move top n cards to directly above the bottom card
         Node end = head;
         for (int i = 1; i < head.prev.data; i++){
            end = end.next;
         }
         if (head.prev.data == 28){ 
            end = end.prev; // to treat both jokers as 27
         }
         Node temp = end.next;
         moveChain(head, end, head.prev.prev);
         head = temp;
      
      // set keyValue = (top card's value)-th card in the deck's value
         Node card = head;
         for (int i = 0; i < head.data; i++){
            card = card.next;
         }
         keyValue = card.data;
      }
      
      return keyValue;
   }

   // switches the data stored in parameters
   private void swapValue (Node a, Node b){ 
      int temp = a.data;
      a.data = b.data;
      b.data = temp;
   }
   
   // returns a pointer to the node with specified value
   private Node findCard(int value){
      Node current = head;
      while (current.data != value){
         current = current.next;
      }
      return current;
   }
   
   //takes nodes from first to last inclusive, insert after location
   // i think this might have a bug when first and last are adjacent 
   // to each other or location, but I didn't have time to fix it
   private void moveChain (Node first, Node last, Node location){
      first.prev.next = last.next;
      last.next.prev = first.prev;
      first.prev = location;
      last.next = location.next;
      location.next.prev = last;
      location.next = first;
   }
   
}